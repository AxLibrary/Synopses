\documentclass{article}

\usepackage[english]{babel}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\usepackage{sectsty}
\allsectionsfont{\centering}

\parindent=0cm
\begin{document}
\title{Lee Copeland - A Practitioner's Guide to Software Test Design}
\author{Tass}
\date{2016/07/25}
\maketitle

\newpage
\section*{The Testing Process}
\textbf{Testing} is a concurrent life cycle process of engineering, using, and maintaining testware in order to measure and improve the quality of the software being tested.
\\
\textbf{Black box testing} is a strategy in which testing is based solely on the requirements and specifications.
\\
\textbf{White box testing} is a strategy in which testing is based on the internal paths, structure, and implementations of the software under test.
\\
\textbf{Four testing levels}: Unit, Integration, System, Acceptance.

\section*{Black Box Testing Techniques}
\begin{itemize}
\item When using black box testing, the tester can never be sure of how much of the system under test has been tested.
\item Even though we can't test everything, formal black box testing directs the tester to choose subsets of tests that are both efficient and effective in finding defects.
\end{itemize}

\section*{Equivalence Class Testing}
\textbf{Equivalence class} consists of a set of data that is treated the same by the module or that should produce the same result. We would expect that:
\begin{itemize}
\item If one test in an equivalence class detects a defect, all other test cases in the same equivalence class are likely to detect the same defect.
\item If one test in an equivalence class doesn't detect a defect, no other test cases in the same equivalence class is likely to detect the defect.
\end{itemize}
\textbf{Testing-by-contract} is based on the design-by-contract philosophy. Its approach is to create test cases only for the situations in which the preconditions are met.
\\
\textbf{Defensive testing} --- an approach to create tests under both normal and abnormal preconditions.
\\
Another approach to using equivalence classes is to \textbf{examine outputs} rather than inputs. Divide the outputs into equivalence classes, then determine what input values would cause those outputs.
\subsection*{Technique:}
\begin{itemize}
\item Identify the equivalence classes.
\item Create a test case for each equivalent class.
\end{itemize}

\section*{Boundary Value Testing}
\textbf{Boundary value testing} focuses on the boundaries because that is where many defects hide. Create test cases for each boundary value by choosing one point on the boundary, one point just below the boundary, and one point just above the boundary.
\subsection*{Technique:}
\begin{itemize}
\item Identify the equivalence classes.
\item Identify the boundaries of each equivalence class.
\item Create test case for each boundary value by choosing one point on the boundary, one point just below the boundary, and one point just above the boundary.
\end{itemize}

\section*{Decision Table Testing}
\textbf{Decision table} are used to document complex business rules, that system must implement. Conditions represent various input conditions, actions are the processes that should be executed depending on the various combinations of input conditions. Each rule defines a unique combination of conditions that results in the execution of the actions, associated with that rule. 
\\
Create at least one test for each rule. If the rule's conditions are binary, a single test for each combination is probably sufficient. If a condition is a range of values, consider testing at both the low and high end of the range.

\section*{Pairwise Testing}
An \textbf{orthogonal array} is a two-dimensional array of numbers that has this interesting property --- choose any two columns in the array, all the combinations will occur in every column pair.
\\
\textbf{All pairs algorithm} generates the pairs without resorting to an "external" device like an orthogonal array.
\end{document}
\documentclass{article}

\usepackage[english]{babel}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\usepackage{sectsty}
\allsectionsfont{\centering}

\parindent=0cm
\begin{document}
\title{Lee Copeland - A Practitioner's Guide to Software Test Design}
\author{Tass}
\date{2016/07/25}
\maketitle

\newpage
\section*{The Testing Process}
\textbf{Testing} is a concurrent life cycle process of engineering, using, and maintaining testware in order to measure and improve the quality of the software being tested.
\\
\textbf{Black box testing} is a strategy in which testing is based solely on the requirements and specifications.
\\
\textbf{White box testing} is a strategy in which testing is based on the internal paths, structure, and implementations of the software under test.
\\
\textbf{Four testing levels}: Unit, Integration, System, Acceptance.

\section*{Black Box Testing Techniques}
\begin{itemize}
\item When using black box testing, the tester can never be sure of how much of the system under test has been tested.
\item Even though we can't test everything, formal black box testing directs the tester to choose subsets of tests that are both efficient and effective in finding defects.
\end{itemize}

\section*{Equivalence Class Testing}
\textbf{Equivalence class} consists of a set of data that is treated the same by the module or that should produce the same result. We would expect that:
\begin{itemize}
\item If one test in an equivalence class detects a defect, all other test cases in the same equivalence class are likely to detect the same defect.
\item If one test in an equivalence class doesn't detect a defect, no other test cases in the same equivalence class is likely to detect the defect.
\end{itemize}
\textbf{Testing-by-contract} is based on the design-by-contract philosophy. Its approach is to create test cases only for the situations in which the preconditions are met.
\\
\textbf{Defensive testing} --- an approach to create tests under both normal and abnormal preconditions.
\\
Another approach to using equivalence classes is to \textbf{examine outputs} rather than inputs. Divide the outputs into equivalence classes, then determine what input values would cause those outputs.
\subsection*{Technique:}
\begin{itemize}
\item Identify the equivalence classes.
\item Create a test case for each equivalent class.
\end{itemize}

\section*{Boundary Value Testing}
\textbf{Boundary value testing} focuses on the boundaries because that is where many defects hide. Create test cases for each boundary value by choosing one point on the boundary, one point just below the boundary, and one point just above the boundary.
\subsection*{Technique:}
\begin{itemize}
\item Identify the equivalence classes.
\item Identify the boundaries of each equivalence class.
\item Create test case for each boundary value by choosing one point on the boundary, one point just below the boundary, and one point just above the boundary.
\end{itemize}

\section*{Decision Table Testing}
\textbf{Decision table} are used to document complex business rules, that system must implement. Conditions represent various input conditions, actions are the processes that should be executed depending on the various combinations of input conditions. Each rule defines a unique combination of conditions that results in the execution of the actions, associated with that rule. 
\\
Create at least one test for each rule. If the rule's conditions are binary, a single test for each combination is probably sufficient. If a condition is a range of values, consider testing at both the low and high end of the range.

\section*{Pairwise Testing}
An \textbf{orthogonal array} is a two-dimensional array of numbers that has this interesting property --- choose any two columns in the array, all the combinations will occur in every column pair.
\\
\textbf{All pairs algorithm} generates the pairs without resorting to an "external" device like an orthogonal array.

\section*{State-Transition Testing}
\textbf{State-Transition diagrams} direct our testing effort by identifying the states, events, actions, and transitions that should be tested. Together, these define how a system interacts with outside world, the events it processes, and the valid and invalid order of these events.
\\
The generally recommended level of testing using state-transition diagrams is to create a set of test cases such that all transitions are exercised at least once under test. In high-risk systems, you may want to create even more test cases, approaching all paths if possible.

\section*{Domain Analysis Testing}
\textbf{Domain analysis} is a technique that can be used to identify efficient and effective test cases when multiple variables should be tested together.
\\
In builds on and generalizes equivalence class and boundary value testing to N simultaneous dimensions. Like those techniques, we are searching for situations where the boundary has been implemented incorrectly.
\\
In using the 1x1 domain analysis technique for each relational condition ($\geq, >, \leq, or <$) we choose one \textbf{on} point and one \textbf{off} point.For each strict equality condition (=) we choose one \textbf{on} point and two \textbf{off} points, one slightly less than the conditional value and one slightly greater than the value.

\section*{Use Case Testing}
A \textbf{use case} is a scenario that describes the use of a system by an actor to accomplish a specific goal.
\\
A major component of transaction testing is a test data. Boris Beizer suggest that 30 percents to 40 percents of the effort in transaction testing is generating, capturing or extracting test data.
\\
While creating at least one test case for the main success scenario and at least one for each extension provides some level of test coverage, it is clear that, no matter how we try, most input combinations will remain untested.

\section*{White Box Testing Techniques}
When using \textbf{white box testing}, the tester can be sure that every path trough the software under test has been identified and tested.
\\
White box testing has four distinct disadvantages:
\begin{itemize}
\item The number of the execution paths may be so large that they cannot all be tested.
\item The test cases chosen may not detect data sensitive errors.
\item White box testing assumes the control flow is correct (or very close to correct). Since the tests are based on the existing paths, nonexistent paths cannot be discovered.
\item The tester must have programming skills to understand and evaluate the software under test.
\end{itemize}


\end{document}